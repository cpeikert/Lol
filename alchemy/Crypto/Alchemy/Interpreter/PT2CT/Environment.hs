{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeFamilies               #-}

-- | Internal helper functions for PT2CT for looking up/generating
-- keys and hints during compilation

module Crypto.Alchemy.Interpreter.PT2CT.Environment
( PT2CTAux, newPT2CTAux, lookupAux
, getKey, getQuadCircHint, getTunnelHint
)
where

import Control.Monad.Random
import Control.Monad.Reader

import Data.Dynamic
import Data.Maybe   (mapMaybe)

import Crypto.Alchemy.MonadAccumulator
import Crypto.Lol
import Crypto.Lol.Applications.SymmSHE

---- Monad helper functions

-- | Holds auxiliary information (keys and hints) generated by PT2CT
-- during compilation.
newtype PT2CTAux = Aux { unAux :: [Dynamic] } deriving (Show, Monoid)

newPT2CTAux :: PT2CTAux
newPT2CTAux = Aux []

-- | Look up a value of the desired type, if it exists.
lookupAux :: (MonadReader PT2CTAux mon, Typeable a) => mon (Maybe a)
lookupAux = (dynLookup . unAux) <$> ask
  where dynLookup :: (Typeable a) => [Dynamic] -> Maybe a
        dynLookup ds = case mapMaybe fromDynamic ds of
          []    -> Nothing
          (x:_) -> Just x

-- | Append a value to the internal state.
appendAux :: (MonadAccumulator PT2CTAux m, Typeable a) => a -> m ()
appendAux a = append $ Aux [toDyn a]

-- | Sequence a, then pass the result to f and return a
(>=<) :: (Monad m) => (a -> m ()) -> m a -> m a
f >=< a = do
  a' <- a
  f a'
  return a'

-- | Lookup a key, generating one if it doesn't exist, and return it.
getKey :: (MonadReader v mon, MonadAccumulator PT2CTAux mon,
           MonadRandom mon, GenSKCtx t m' z v, Typeable (Cyc t m' z))
  => mon (SK (Cyc t m' z))
getKey = embedReader lookupAux >>= \case
  (Just t) -> return t
  -- generate a key with the variance stored in the Reader monad
  Nothing -> do
    v <- ask
    appendAux >=< genSK v

-- | Lookup a (quadratic, circular) key-switch hint, generating one
-- (and the underlying key if necessary) if it doesn't exist, and
-- return it.
getQuadCircHint :: forall v mon t z gad m' zq zq' kszq .
  (-- constraints for getKey
   MonadReader v mon, MonadAccumulator PT2CTAux mon,
   MonadRandom mon, GenSKCtx t m' z v, Typeable (Cyc t m' z),
   -- constraints for lookup
   Typeable (KSQuadCircHint gad (Cyc t m' zq')),
   -- constraints for ksQuadCircHint
   KSHintCtx gad t m' z zq', zq' ~ (kszq, zq))
  => Proxy z -> mon (KSQuadCircHint gad (Cyc t m' zq'))
getQuadCircHint _ = embedReader lookupAux >>= \case
  (Just h) -> return h
  Nothing -> do
    sk :: SK (Cyc t m' z) <- getKey
    appendAux >=< ksQuadCircHint sk

-- not memoized right now, but could be if we also store the linear function as part of the lookup key
-- EAC: https://ghc.haskell.org/trac/ghc/ticket/13490
getTunnelHint :: forall gad zq mon t e r s e' r' s' z zp v .
  (MonadReader v mon, MonadAccumulator PT2CTAux mon, MonadRandom mon,
   GenSKCtx t r' z v, Typeable (Cyc t r' (LiftOf zp)),
   GenSKCtx t s' z v, Typeable (Cyc t s' (LiftOf zp)),
   TunnelHintCtx t e r s e' r' s' z zp zq gad,
   z ~ LiftOf zp)
  => Linear t zp e r s -> mon (TunnelHint gad t e r s e' r' s' zp zq)
getTunnelHint linf = do
  skout <- getKey @_ @_ @_ @_ @z
  skin <- getKey @_ @_ @_ @_ @z
  tunnelHint linf skout skin
